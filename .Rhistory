cacheSolve(B)
makeCacheMatrix(B)
cacheSolve(B)
mtx <- makeCacheMatrix(matrix(c(1, 4, 4, 1), ncol=2))
mtx$get()
inv = cacheSolve(mtx)
inv
cacheSolve(mtx)
solve(mtx, ...)
solve(mtx)
mtx <- makeCacheMatrix(matrix(c(4, 2, 7, 6), ncol=2))
cacheSolve(mtx)
cacheSolve(mtx)
mtcars
|> Seq.groupBy (fun x -> x?cyl)
|> Seq.sortBy fst
|> Seq.map (fun (key, values) -> key, values |> Seq.averageBy (fun x -> x?mpg.AsFloat()))
//Continuing with the 'mtcars' dataset from Question 6, what is the absolute difference between the average horsepower of 4-cylinder cars and the average horsepower of 8-cylinder cars?
let avg4cyl = mtcars |> Seq.filter (fun x -> x?cyl = "4") |> Seq.averageBy (fun x -> x?hp.AsFloat())
let avg8cyl = mtcars |> Seq.filter (fun x -> x?cyl = "8") |> Seq.averageBy (fun x -> x?hp.AsFloat())
abs(avg4cyl - avg8cyl)
library(datasets)
data(mtcars)
mtcars
|> Seq.groupBy (fun x -> x?cyl)
|> Seq.sortBy fst
|> Seq.map (fun (key, values) -> key, values |> Seq.averageBy (fun x -> x?mpg.AsFloat()))
//Continuing with the 'mtcars' dataset from Question 6, what is the absolute difference between the average horsepower of 4-cylinder cars and the average horsepower of 8-cylinder cars?
let avg4cyl = mtcars |> Seq.filter (fun x -> x?cyl = "4") |> Seq.averageBy (fun x -> x?hp.AsFloat())
let avg8cyl = mtcars |> Seq.filter (fun x -> x?cyl = "8") |> Seq.averageBy (fun x -> x?hp.AsFloat())
abs(avg4cyl - avg8cyl)
avg4cyl <- split(mtcars, mtcars$cyl = 4)
mtcars[1,]
getOutcomes <- function(){
outcomes=c('heart attack','heart disease','pneumonia')
#build dictionary for column name and outcome
outcome_columns=c(11,17,23)
names(outcome_columns)=outcomes
return(outcome_columns)
}
getIdx <- function(outcome){
outcomes=getOutcomes()
#check if outcome is valid
if (!outcome %in% names(outcomes)){
stop("invalid outcome")}
idx=outcomes[outcome]
return(idx)
}
getData <- function(state){
## Read outcome data
##you should specify your own working directory
data=read.csv("outcome-of-care-measures.csv",colClasses="character")
## Check that state and outcome are valid
str_states <- data$State
if (!state %in% str_states){
stop("Invalid state")
}
return(data)
}
prepareData <- function(data){
#Prepare data
for(i in getOutcomes()){
data[,i] <- suppressWarnings(as.numeric(as.character(data[,i])))
}
data$State <- factor(data$State)
return(data)
}
cleanNA <- function(data){
# clean up NA
cc = complete.cases(data)
data = data[cc,]
return(data)
}
## If you want to source() a bunch of files, something like
## the following may be useful:
sourceDir <- function(path, trace = TRUE, ...) {
for (nm in list.files(path, pattern = "\\.[RrSsQq]$")) {
if(trace) cat(nm,":")
source(file.path(path, nm), ...)
if(trace) cat("\n")
}
}
source("./utils.R",local=TRUE)
best <- function(state, outcome) {
outcomes=getOutcomes()
## Read outcome data
data=getData(state)
#Prepare data
data=prepareData(data)
data = data[data$State == state,]
# clean up NA
data=cleanNA(data)
idx=getIdx(outcome)
t_data <- data[!is.na(data[,idx]),]
return(t_data[which.min(t_data[,idx]),2])
## Return hospital name in that state with lowest 30-day death
## rate
}
best("TX", "heart attack")
getOutcomes <- function(){
outcomes=c('heart attack','heart disease','pneumonia')
#build dictionary for column name and outcome
outcome_columns=c(11,17,23)
names(outcome_columns)=outcomes
return(outcome_columns)
}
getIdx <- function(outcome){
outcomes=getOutcomes()
#check if outcome is valid
if (!outcome %in% names(outcomes)){
stop("invalid outcome")}
idx=outcomes[outcome]
return(idx)
}
getData <- function(state){
## Read outcome data
##you should specify your own working directory
data=read.csv("/Users/benakiva/Dropbox/Coursera/R Programming/Week4/programming assignment/rprog-data-ProgAssignment3-data/outcome-of-care-measures.csv",colClasses="character")
## Check that state and outcome are valid
str_states <- data$State
if (!state %in% str_states){
stop("Invalid state")
}
return(data)
}
prepareData <- function(data){
#Prepare data
for(i in getOutcomes()){
data[,i] <- suppressWarnings(as.numeric(as.character(data[,i])))
}
data$State <- factor(data$State)
return(data)
}
cleanNA <- function(data){
# clean up NA
cc = complete.cases(data)
data = data[cc,]
return(data)
}
## If you want to source() a bunch of files, something like
## the following may be useful:
sourceDir <- function(path, trace = TRUE, ...) {
for (nm in list.files(path, pattern = "\\.[RrSsQq]$")) {
if(trace) cat(nm,":")
source(file.path(path, nm), ...)
if(trace) cat("\n")
}
}
source("./utils.R",local=TRUE)
best <- function(state, outcome) {
outcomes=getOutcomes()
## Read outcome data
data=getData(state)
#Prepare data
data=prepareData(data)
data = data[data$State == state,]
# clean up NA
data=cleanNA(data)
idx=getIdx(outcome)
t_data <- data[!is.na(data[,idx]),]
return(t_data[which.min(t_data[,idx]),2])
## Return hospital name in that state with lowest 30-day death
## rate
}
best("TX", "heart attack")
best("TX", "heart failure")
best("MD", "heart attack")
getOutcomes <- function(){
outcomes=c('heart attack','heart failure','pneumonia')
#build dictionary for column name and outcome
outcome_columns=c(11,17,23)
names(outcome_columns)=outcomes
return(outcome_columns)
}
getIdx <- function(outcome){
outcomes=getOutcomes()
#check if outcome is valid
if (!outcome %in% names(outcomes)){
stop("invalid outcome")}
idx=outcomes[outcome]
return(idx)
}
getData <- function(state){
## Read outcome data
##you should specify your own working directory
data=read.csv("/Users/benakiva/Dropbox/Coursera/R Programming/Week4/programming assignment/rprog-data-ProgAssignment3-data/outcome-of-care-measures.csv",colClasses="character")
## Check that state and outcome are valid
str_states <- data$State
if (!state %in% str_states){
stop("Invalid state")
}
return(data)
}
prepareData <- function(data){
#Prepare data
for(i in getOutcomes()){
data[,i] <- suppressWarnings(as.numeric(as.character(data[,i])))
}
data$State <- factor(data$State)
return(data)
}
cleanNA <- function(data){
# clean up NA
cc = complete.cases(data)
data = data[cc,]
return(data)
}
## If you want to source() a bunch of files, something like
## the following may be useful:
sourceDir <- function(path, trace = TRUE, ...) {
for (nm in list.files(path, pattern = "\\.[RrSsQq]$")) {
if(trace) cat(nm,":")
source(file.path(path, nm), ...)
if(trace) cat("\n")
}
}
source("./utils.R",local=TRUE)
best <- function(state, outcome) {
outcomes=getOutcomes()
## Read outcome data
data=getData(state)
#Prepare data
data=prepareData(data)
data = data[data$State == state,]
# clean up NA
data=cleanNA(data)
idx=getIdx(outcome)
t_data <- data[!is.na(data[,idx]),]
return(t_data[which.min(t_data[,idx]),2])
## Return hospital name in that state with lowest 30-day death
## rate
}
best("TX", "heart failure")
best("TX", "heart attack")
best("MD", "heart attack")
best("MD", "pneumonia")
## This function creates a special "vector" containing a function to
## - set the value of the matrix
## - get the value of the matrix
## - set the value of the inverse
## - get the value of the inverse
makeCacheMatrix <- function(x = matrix()) {
# initialize the stored matrix inverse value to NULL
mtxInv <- NULL
set <- function(y) {
x <<- y
mtxInv <<- NULL
}
get <- function() x
setMatrixInverse <- function(inv) mtxInv <<- inv
getMatrixInverse <- function() mtxInv
list(set = set, get = get,
setMatrixInverse = setMatrixInverse,
getMatrixInverse = getMatrixInverse)
}
## This function retrieves the matrix inverse value
## from the cache if it exits. In case the inverse of
## a matrix does not exist in the cache, the function
## calculates it and store the result in the cache and
## returns the value calculated.
cacheSolve <- function(x, ...) {
# check if the inverse is already cached
mtxInv <- x$getMatrixInverse()
# if the matrix inverse exits in the cache,
# we return it here
if(!is.null(mtxInv)) {
message("getting cached matrix inverse")
return(mtxInv)
}
# if the matrix inverse isn't in the cached,
# we get the matrix into data
message("matrix inverse not in the cache. Computing it...")
data <- x$get()
# compute the matrix inverse
mtxInv <- solve(data, ...)
# set in to the cache the computed inverse
x$setMatrixInverse(mtxInv)
## Return a matrix that is the inverse of 'x'
mtxInv
}
cacheMatrix <- makeCacheMatrix(matrix(1:4,2,2,4))
cacheMatrix$Get()
cacheMatrix$get()
inverseMatrix <- cacheSolve(cacheMatrix)
inverseMatrix
ls()
df = read.table("./household_power_consumption.txt", header=T, sep=';')
newData1 <- as.character(df$Date)
df$newdate <- strptime(newData1, "%d/%m/%Y")
df$Date <- df$newdate
dat4 <- df[df$Date >= as.POSIXlt("2007-02-01") & df$Date < as.POSIXlt("2007-02-02"),]
png("./plot1.png", width = 480, height = 480)
hist(as.numeric(as.character(dat4$Global_active_power)), col = "red",
main = "Global Active Power",
xlab = "Global Active Power (kilowatts)")
dev.off()
library("httr")
# 1. Find OAuth settings for github:
#    http://developer.github.com/v3/oauth/
oauth_endpoints("github")
# 2. Register an application at https://github.com/settings/applications
#    Insert your values below - if secret is omitted, it will look it up in
#    the GITHUB_CONSUMER_SECRET environmental variable.
#
#    Use http://localhost:1410 as the callback url
myapp <- oauth_app("RGitHub", "cb85aa17df80adc6fe4a", "bff9d09356d49dda596fc5b7d86e6c4ef2bad8d8")
# 3. Get OAuth credentials
github_token <- oauth2.0_token(oauth_endpoints("github"), myapp)
library("httr")
# 1. Find OAuth settings for github:
#    http://developer.github.com/v3/oauth/
oauth_endpoints("github")
# 2. Register an application at https://github.com/settings/applications
#    Insert your values below - if secret is omitted, it will look it up in
#    the GITHUB_CONSUMER_SECRET environmental variable.
#
#    Use http://localhost:1410 as the callback url
myapp <- oauth_app("RGitHub", "cb85aa17df80adc6fe4a", "bff9d09356d49dda596fc5b7d86e6c4ef2bad8d8")
# 3. Get OAuth credentials
github_token <- oauth2.0_token(oauth_endpoints("github"), myapp)
# 4. Use API
req <- GET("https://api.github.com/users/jtleek/repos", config(token = github_token))
stop_for_status(req)
content(req)
library("httr")
oauth_endpoints("github")
myapp <- oauth_app("RGitHub", "cb85aa17df80adc6fe4a", "bff9d09356d49dda596fc5b7d86e6c4ef2bad8d8")
github_token <- oauth2.0_token(oauth_endpoints("github"), myapp)
library(httpuv)
library("httpuv"")
library("httpuv")
library("httr")
library("httpuv")
library("jsonlite")
# 1. Find OAuth settings for github:
#    http://developer.github.com/v3/oauth/
oauth_endpoints("github")
# 2. Register an application at https://github.com/settings/applications
#    Insert your values below - if secret is omitted, it will look it up in
#    the GITHUB_CONSUMER_SECRET environmental variable.
#
#    Use http://localhost:1410 as the callback url
myapp <- oauth_app("RGitHub", "cb85aa17df80adc6fe4a", "bff9d09356d49dda596fc5b7d86e6c4ef2bad8d8")
# 3. Get OAuth credentials
github_token <- oauth2.0_token(oauth_endpoints("github"), myapp)
# 4. Use API
req <- GET("https://api.github.com/users/jtleek/repos", config(token = github_token))
stop_for_status(req)
content(req)
library(sqldf)
?numcolwise
?ddply
install.packages("plyr")
?ddply
install.packages("dplyr")
?read.csv
()
getwd()
setwd("~/Dropbox (Personal)/Coursera/Reproducible Research/Week2/peer_assessment1/RepData_PeerAssessment1")
data <- read.csv("activity.csv", header = TRUE, sep = ",")
summary(data)
header(data)
head(data)
data
str(data)
names(data)
head(data)
library(data.table)
activity_table <- data.table(data)
head(activity_table)
str(activity_table)
act_summary <- activity_table[, list(total_steps = sum(steps, na.rm = T)),
by = date]
act_summary
hist(act_summary)
hist(act_summary.total_steps)
hist(act_summary$total_steps)
gen_hist = function(x, title){
hist(x,
breaks = 20,
main = title,
xlab = 'Total Number of Steps', col = 'grey',
cex.main = .9)
#caluclate mean and median
mean_value = round(mean(x), 1)
median_value = round(median(x), 1)
#place lines for mean and median on histogram
abline(v=mean_value, lwd = 3, col = 'blue')
abline(v=median_value, lwd = 3, col = 'red')
#create legend
legend('topright', lty = 1, lwd = 3, col = c("blue", "red"),
cex = .8,
legend = c(paste('Mean: ', mean_value),
paste('Median: ', median_value))
)
}
gen_hist(act_summary$total_steps, "Total Number of Steps Taken per Day")
num_steps <- tapply(activity_data$steps, activity_data$date, sum, na.rm = TRUE)
num_steps <- tapply(data$steps, data$date, sum, na.rm = TRUE)
num_steps
hist(data$steps, breaks = 20, "Number steps per Day", xlab = 'Total Number of Steps', col = 'blue')
hist(data$steps)
gen_hist(act_summary$total_steps, "Total Number of Steps Taken per Day")
hist(data$steps, breaks = 20, main = "Number steps per Day", xlab = 'Total Number of Steps', col = 'blue', cex.main = .9)
total_steps <- aggregate(activity_data$steps ~ activity_data$date, tidy, sum)
total_steps <- aggregate(activity_data$steps ~ activity_data$date, activity_data, sum)
total_steps <- aggregate(steps ~ date, data, sum)
total_steps
hist(total_steps$steps, breaks = 20, main = "Number steps per Day", xlab = 'Total Number of Steps', col = 'blue', cex.main = .9)
activity_data <- read.csv("activity.csv", header = TRUE, sep = ",")
activity_data$date <- as.Date(activity_data$date, format="%Y-%m-%d")
activity_data$interval <- factor(activity_data$interval)
num_steps <- tapply(activity_data$steps, activity_data$date, sum, na.rm = TRUE)
hist(num_steps$steps, breaks = 20, main = "Number steps per Day", xlab = 'Total Number of Steps', col = 'blue', cex.main = .9)
hist(num_steps, breaks = 20, main = "Number steps per Day", xlab = 'Total Number of Steps', col = 'blue', cex.main = .9)
hist(num_steps, breaks = 20, main = "Number steps per Day", xlab = 'Total Number of Steps', col = 'blue', cex.main = .5)
hist(num_steps, breaks = 20, main = "Number steps per Day", xlab = 'Total Number of Steps', col = 'blue', cex.main = .9)
hist(num_steps, breaks = 20, main = "Number steps per Day", xlab = 'Total Number of Steps', col = 'blue')
num_steps
mean(num_steps$steps)
names(num_steps)
mean(num_steps)
median(num_steps)
aggregate(
data=activity_data,
steps~interval,
FUN=mean,
na.action=na.omit
)
steps_interval <- aggregate(
data=activity_data,
steps~interval,
FUN=mean,
na.action=na.omit
)
with(steps_interval, {
plot(
x=interval,
y=steps,
type="l",
main="Time-Series of Average Steps against Interval",
xlab="5-minute Interval",
ylab="Average Steps, Average across all Days"
)
})
?plot()
with(steps_interval, {
plot(
x=interval,
y=steps,
type="l",
main="Time-Series of Average Steps against Interval",
xlab="5-minute Interval",
ylab="Average Steps, Average across all Days", lwd = 10
)
})
with(steps_interval, {
plot(
x=interval,
y=steps,
type="l",
main="Time-Series of Average Steps against Interval",
xlab="5-minute Interval",
ylab="Average Steps, Average across all Days", lwd = 3
)
})
with(steps_interval, {
plot(
x=interval,
y=steps,
type="l",
main="Time-Series of Average Steps against Interval",
xlab="5-minute Interval",
ylab="Average Steps, Average across all Days", lwd = 3, pch = 19
)
})
with(steps_interval, {
plot(
x=interval,
y=steps,
type="l",
main="Time-Series of Average Steps against Interval",
xlab="5-minute Interval",
ylab="Average Steps, Average across all Days", lwd = 3, pch = 19
)
})
with(steps_interval, { plot(interval, steps, type = "l", main="Time-Series of Average Steps against Interval", xlab="5-minute Interval",ylab="Average Steps, Average across all Days", lwd = 3, pch = 19)})
with(steps_interval, { plot(interval, steps, type = "l", main="Time-Series of Average Steps against Interval", xlab="5-minute Interval",ylab="Average Steps, Average across all Days", pch = 19)})
points(steps_interval$interval,  steps_interval$steps, col = 'red', lwd = 3, pch = 19)
points(steps_interval$interval,  steps_interval$steps, col = 'red', lwd = 2, pch = 19)
points(steps_interval$interval,  steps_interval$steps, col = 'red', lwd = 2, pch = 18)
points(steps_interval$interval,  steps_interval$steps, col = 'red', lwd = 2, pch = 1)
points(steps_interval$interval,  steps_interval$steps, col = 'grey', lwd = 2, pch = 1)
points(steps_interval$interval,  steps_interval$steps, col = 'grey', lwd = 2, pch = 19)
plot(interval, steps, type = "l")
plot(steps_interval$interval, steps_interval$steps, type = "l")
?aggregate()
stepsByInterval <- aggregate(steps~interval, data = activity_data, FUN = mean, na.action = na.omit())
?na.omit
stepsByInterval <- aggregate(steps~interval, data = activity_data, FUN = mean, na.action = na.omit)
plot(stepsByInterval$interval, stepsByInterval$steps, type = "l")
steps_interval$interval[which.max(steps_interval$steps)]
max_steps <- steps_interval$interval[which.max(steps_interval$steps)]
print(max_steps)
max_steps[1]
max_steps[0]
head(max_steps)
summary(max_steps)
max_steps <- steps_interval$interval[which.max(steps_interval$steps), 1]
max_steps <- steps_interval$interval[which.max(steps_interval$steps), ]
max_steps <- steps_interval$interval[which.max(steps_interval$steps)]
max_steps
